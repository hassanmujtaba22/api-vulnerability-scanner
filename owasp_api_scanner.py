import requests
import json
import concurrent.futures
import re
import time
import logging
from typing import List, Dict, Any
from urllib.parse import urljoin

class OWASPAPIScanner:
    def __init__(self, base_url: str, headers: Dict = None):
        """
        Initialize OWASP API security scanner
        """
        self.base_url = base_url
        self.headers = headers or {}
        self.findings = []
        self.session = requests.Session()
        self.logger = self._setup_logger()

    def _setup_logger(self):
        """Configure logging"""
        logging.basicConfig(level=logging.INFO)
        return logging.getLogger("OWASPAPIScanner")

    def check_broken_object_level_authorization(self, endpoint: str) -> List[str]:
        """API1:2019 Broken Object Level Authorization"""
        findings = []
        test_ids = [1, 2, 999999]
        
        for test_id in test_ids:
            try:
                test_endpoints = [
                    f"{endpoint}/{test_id}",
                    f"{endpoint}?user_id={test_id}",
                    f"{endpoint}?id={test_id}"
                ]
                
                for test_endpoint in test_endpoints:
                    response = self.session.get(
                        urljoin(self.base_url, test_endpoint),
                        headers=self.headers
                    )
                    
                    if response.status_code == 200:
                        findings.append(f"Potential BOLA: Successfully accessed {test_endpoint} without proper authorization")
                        sensitive_fields = ['password', 'ssn', 'credit_card', 'token']
                        try:
                            response_data = response.json()
                            for field in sensitive_fields:
                                if field in str(response_data).lower():
                                    findings.append(f"Sensitive data exposure in {test_endpoint}: {field}")
                        except json.JSONDecodeError:
                            pass
                        
            except requests.exceptions.RequestException as e:
                self.logger.error(f"Error testing BOLA on {endpoint}: {str(e)}")
                
        return findings

    def check_broken_authentication(self, endpoint: str) -> List[str]:
        """API2:2019 Broken Authentication"""
        findings = []
        auth_tests = [
            {"headers": {}, "desc": "No authentication"},
            {"headers": {"Authorization": "Bearer invalid_token"}, "desc": "Invalid token"},
            {"headers": {"Authorization": "Bearer null"}, "desc": "Null token"},
            {"headers": {"Authorization": "Bearer " + "A" * 1000}, "desc": "Very long token"}
        ]
        
        for test in auth_tests:
            try:
                response = self.session.get(
                    urljoin(self.base_url, endpoint),
                    headers=test["headers"]
                )
                
                if response.status_code == 200:
                    findings.append(f"Authentication bypass possible with {test['desc']}")
                    
            except requests.exceptions.RequestException as e:
                self.logger.error(f"Error testing authentication: {str(e)}")

        try:
            weak_passwords = ["password123", "admin", "12345"]
            for password in weak_passwords:
                response = self.session.post(
                    urljoin(self.base_url, endpoint),
                    json={"username": "test", "password": password}
                )
                
                if response.status_code == 200:
                    findings.append(f"Weak password '{password}' might be accepted")
                    
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error testing password policy: {str(e)}")

        return findings

    def check_excessive_data_exposure(self, endpoint: str) -> List[str]:
        """API3:2019 Excessive Data Exposure"""
        findings = []
        
        try:
            response = self.session.get(urljoin(self.base_url, endpoint), headers=self.headers)
            
            if response.status_code == 200:
                try:
                    data = response.json()
                    sensitive_patterns = {
                        'password': r'password|passwd|pwd',
                        'credit_card': r'\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}',
                        'ssn': r'\d{3}-\d{2}-\d{4}',
                        'email': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
                        'api_key': r'api[_-]?key|private[_-]?key'
                    }
                    
                    data_str = json.dumps(data)
                    for data_type, pattern in sensitive_patterns.items():
                        if re.search(pattern, data_str, re.IGNORECASE):
                            findings.append(f"Potential excessive data exposure: {data_type} found in response")
                            
                except json.JSONDecodeError:
                    pass
                
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error testing data exposure: {str(e)}")
            
        return findings

    def check_lack_of_resources_and_rate_limiting(self, endpoint: str) -> List[str]:
        """API4:2019 Lack of Resources & Rate Limiting"""
        findings = []
        request_count = 50
        start_time = time.time()
        successful_requests = 0
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            futures = []
            for _ in range(request_count):
                futures.append(
                    executor.submit(
                        self.session.get,
                        urljoin(self.base_url, endpoint),
                        headers=self.headers
                    )
                )
                
            for future in concurrent.futures.as_completed(futures):
                try:
                    response = future.result()
                    if response.status_code == 200:
                        successful_requests += 1
                except requests.exceptions.RequestException:
                    pass
                    
        elapsed_time = time.time() - start_time
        requests_per_second = successful_requests / elapsed_time
        
        if requests_per_second > 10:
            findings.append(f"Potential lack of rate limiting: Achieved {requests_per_second:.2f} requests/second")

        try:
            large_payload = {"data": "A" * 1000000}  # 1MB of data
            response = self.session.post(
                urljoin(self.base_url, endpoint),
                json=large_payload,
                headers=self.headers
            )
            
            if response.status_code == 200:
                findings.append("Large payload accepted without restriction")
                
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error testing resource limits: {str(e)}")
            
        return findings

    def check_security_misconfiguration(self, endpoint: str) -> List[str]:
        """API7:2019 Security Misconfiguration"""
        findings = []
        
        try:
            headers = {
                **self.headers,
                'Origin': 'http://evil-site.com'
            }
            
            response = self.session.options(
                urljoin(self.base_url, endpoint),
                headers=headers
            )
            
            if 'Access-Control-Allow-Origin' in response.headers and response.headers['Access-Control-Allow-Origin'] == '*':
                findings.append("Insecure CORS configuration: Allows all origins")
                
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'Strict-Transport-Security': 'Missing HSTS header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header'
            }
            
            response = self.session.get(urljoin(self.base_url, endpoint), headers=self.headers)
            
            for header, message in security_headers.items():
                if header not in response.headers:
                    findings.append(message)
                    
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Error testing security configuration: {str(e)}")
            
        return findings

    def scan_api(self, endpoints: List[str]):
        """Scan multiple API endpoints for OWASP Top 10 vulnerabilities"""
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            future_to_endpoint = {
                executor.submit(self.scan_endpoint, endpoint): endpoint
                for endpoint in endpoints
            }
            
            for future in concurrent.futures.as_completed(future_to_endpoint):
                endpoint = future_to_endpoint[future]
                try:
                    findings = future.result()
                    self.findings.extend(findings)
                except Exception as e:
                    self.findings.append(f"Error scanning {endpoint}: {str(e)}")

    def scan_endpoint(self, endpoint: str) -> List[str]:
        """Run all OWASP API security checks on a single endpoint"""
        all_findings = []
        
        checks = [
            self.check_broken_object_level_authorization,
            self.check_broken_authentication,
            self.check_excessive_data_exposure,
            self.check_lack_of_resources_and_rate_limiting,
            self.check_security_misconfiguration
        ]
        
        for check in checks:
            findings = check(endpoint)
            all_findings.extend(findings)
            
        return all_findings

    def generate_report(self) -> str:
        """Generate a security scan report"""
        report = {
            "scan_time": time.strftime("%Y-%m-%d %H:%M:%S"),
            "target_api": self.base_url,
            "total_findings": len(self.findings),
            "findings": self.findings
        }
        
        return json.dumps(report, indent=2)

if __name__ == "__main__":
    # Example usage
    base_url = "https://juice-shop.herokuapp.com/#/"  # Example Juice Shop local setup
    endpoints = ["/rest/products", "/rest/users"]
    
    # Initialize scanner with optional headers (e.g., API key)
    headers = {
        # "Authorization": "Bearer eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY1ZDRlN2UxYTM1NDczNDU2YzVkNDhiZCIsImVtYWlsIjoiaGFzc2FuLm11anRhYmFAY2FjaWxpYW4uY29tIiwicm9sZSI6IkFETUlOIiwidG9rZW5UeXBlIjoiTE9HSU4iLCJoYXNoIjoiZWQ4YjFjZmE0NTEyMDY3MzU5ZjE4MjFkMTUzOWQ3ZmQzNDA3YmY3Yjk3NWE2Y2NiOTU1YzRiODM5NzFjNWI1ZTliYjIzNDM5M2E4YjU4YjBhYWJkZTA0ZTZkYzhiYjg2NzFjNzJmMmY0YTg5ZWEzNWJiM2U1NjdlMmZhZWI4YzAiLCJpYXQiOjE3MzA4OTMxODUsImV4cCI6MTczMDk3OTU4NX0.V4wVqizE58_mqBSV5va2euRVmJLd49SPdD9ZrEqZNoHFrx06A10R8ghOij3hpDqRyefPLxrXMOW-pc06eEHU0g"
    }

    # Instantiate the OWASP API scanner
    scanner = OWASPAPIScanner(base_url, headers)

    # Run the scan on all specified endpoints
    scanner.scan_api(endpoints)

    # Print the report
    report = scanner.generate_report()
    print(report)
