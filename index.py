import requests
import json
import concurrent.futures
from urllib.parse import urljoin
import time

class APISecurityScanner:
    def __init__(self, base_url, headers=None):
        """Initialize scanner with base URL and optional headers"""
        self.base_url = base_url
        self.headers = headers or {}
        self.findings = []
        
    def check_http_methods(self, endpoint):
        """Test for unsafe HTTP methods"""
        unsafe_methods = ['PUT', 'DELETE', 'TRACE', 'OPTIONS']
        findings = []
        
        for method in unsafe_methods:
            try:
                response = requests.request(method, urljoin(self.base_url, endpoint), headers=self.headers)
                if response.status_code != 405:  # Method should be not allowed
                    findings.append(f"Potentially unsafe HTTP method {method} allowed on {endpoint}")
            except requests.exceptions.RequestException as e:
                findings.append(f"Error testing {method} on {endpoint}: {str(e)}")
                
        return findings

    def check_rate_limiting(self, endpoint, requests_count=50, interval=5):
        """Test for rate limiting"""
        start_time = time.time()
        success_count = 0
        
        for _ in range(requests_count):
            try:
                response = requests.get(urljoin(self.base_url, endpoint), headers=self.headers)
                if response.status_code == 200:
                    success_count += 1
            except requests.exceptions.RequestException:
                pass
                
        elapsed_time = time.time() - start_time
        requests_per_second = success_count / elapsed_time
        
        if requests_per_second > 10:  # Arbitrary threshold
            return [f"Possible lack of rate limiting on {endpoint}. Achieved {requests_per_second:.2f} requests/second"]
        return []

    def check_authentication(self, endpoint):
        """Test for authentication requirements"""
        try:
            # Try without auth headers
            no_auth_headers = self.headers.copy()
            no_auth_headers.pop('Authorization', None)
            response = requests.get(urljoin(self.base_url, endpoint), headers=no_auth_headers)
            
            if response.status_code == 200:
                return [f"Endpoint {endpoint} accessible without authentication"]
        except requests.exceptions.RequestException as e:
            return [f"Error testing authentication on {endpoint}: {str(e)}"]
        return []

    def check_error_handling(self, endpoint):
        """Test error handling and information disclosure"""
        findings = []
        
        # Test with malformed JSON
        try:
            response = requests.post(
                urljoin(self.base_url, endpoint),
                data="malformed{json",
                headers={"Content-Type": "application/json", **self.headers}
            )
            
            if response.status_code == 500:
                findings.append(f"Internal Server Error exposed on {endpoint}")
                
            # Check for stack traces or sensitive info in response
            response_text = response.text.lower()
            sensitive_terms = ['stack trace', 'exception', 'sql', 'debug']
            
            for term in sensitive_terms:
                if term in response_text:
                    findings.append(f"Possible sensitive information disclosure ({term}) in error response on {endpoint}")
                    
        except requests.exceptions.RequestException as e:
            findings.append(f"Error testing error handling on {endpoint}: {str(e)}")
            
        return findings

    def scan_endpoint(self, endpoint):
        """Run all security checks on a single endpoint"""
        all_findings = []
        
        checks = [
            self.check_http_methods,
            self.check_authentication,
            self.check_rate_limiting,
            self.check_error_handling
        ]
        
        for check in checks:
            findings = check(endpoint)
            all_findings.extend(findings)
            
        return all_findings

    def scan_api(self, endpoints):
        """Scan multiple endpoints concurrently"""
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            future_to_endpoint = {
                executor.submit(self.scan_endpoint, endpoint): endpoint 
                for endpoint in endpoints
            }
            
            for future in concurrent.futures.as_completed(future_to_endpoint):
                endpoint = future_to_endpoint[future]
                try:
                    findings = future.result()
                    if findings:
                        self.findings.extend(findings)
                except Exception as e:
                    self.findings.append(f"Error scanning {endpoint}: {str(e)}")

    def generate_report(self):
        """Generate a security scan report"""
        report = {
            "scan_time": time.strftime("%Y-%m-%d %H:%M:%S"),
            "target_api": self.base_url,
            "total_findings": len(self.findings),
            "findings": self.findings
        }
        
        return json.dumps(report, indent=2)


if __name__ == "__main__":
    # Example usage
    base_url = "http://localhost:8080"  # Replace with the base URL of your API
    endpoints = ["/users/current/user"]  # List of endpoints to scan
    
    # Initialize scanner with optional headers (e.g., API key)
    headers = {
        "Authorization": "Bearer eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY1ZDRlN2UxYTM1NDczNDU2YzVkNDhiZCIsImVtYWlsIjoiaGFzc2FuLm11anRhYmFAY2FjaWxpYW4uY29tIiwicm9sZSI6IkFETUlOIiwidG9rZW5UeXBlIjoiTE9HSU4iLCJoYXNoIjoiZWQ4YjFjZmE0NTEyMDY3MzU5ZjE4MjFkMTUzOWQ3ZmQzNDA3YmY3Yjk3NWE2Y2NiOTU1YzRiODM5NzFjNWI1ZTliYjIzNDM5M2E4YjU4YjBhYWJkZTA0ZTZkYzhiYjg2NzFjNzJmMmY0YTg5ZWEzNWJiM2U1NjdlMmZhZWI4YzAiLCJpYXQiOjE3MzA4OTMxODUsImV4cCI6MTczMDk3OTU4NX0.V4wVqizE58_mqBSV5va2euRVmJLd49SPdD9ZrEqZNoHFrx06A10R8ghOij3hpDqRyefPLxrXMOW-pc06eEHU0g"  # Replace with your actual token if needed
    }
    
    scanner = APISecurityScanner(base_url, headers=headers)
    scanner.scan_api(endpoints)
    
    # Generate and print the security scan report
    report = scanner.generate_report()
    print(report)